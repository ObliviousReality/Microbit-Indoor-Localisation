// DMESG("Pull Req");
    // auto rawData = audioStream.pull();
    // samples = (int16_t *)&rawData[0];
    // this->dataPoint = samples[0];
    // length = rawData.length() / 2;

    int result;
    auto mic_samples = audioStream.pull();
    DMESG("SAMPLE RATE: %d", audioStream.getSampleRate());

    if (!recording)
        return DEVICE_OK;

    int8_t *data = (int8_t *)&mic_samples[0];
    // DMESG("FIRST SAMPLE: %d", mic_samples[0]);
    int sum = 0;
    for (int i = 0; i < mic_samples.length(); i++)
    {
        sum += mic_samples[i];
    }
    DMESG("AVERAGE: %d", sum / mic_samples.length());
    int samples = mic_samples.length() / 2;
    // DMESG("%s %d", "samples", samples);
    for (int i = 0; i < samples; i++)
    {

        result = (int)*data;

        data++;
        buf[position++] = (float)result;
        if (!(position % AUDIO_SAMPLES_NUMBER))
        {
            // position = 0;
            uint16_t offset = position <= AUDIO_SAMPLES_NUMBER ? 0 : AUDIO_SAMPLES_NUMBER;
            DMESG("%d", offset);
            DMESG("BREAK");
            break;
        }
    }
    // DMESG("Pos: %d", position);
    // for (int i = 0; i < position; i++)
    // {
    //     DMESG("%d", buf[i]);
    // }
    position = 0;
    return DEVICE_OK;




    #include "MicroBit.h"
#include "DataStream.h"
#define ARM_MATH_CM4
#include "arm_math.h"

#ifndef FFT_H
#define FFT_H

#define SAMPLE_RATE (11 * 1024)
#define AUDIO_SAMPLES_NUMBER 1024

class FFT : public DataSink
{
    DataSource &audioStream;

public:
    FFT(DataSource &s);
    ~FFT();
    virtual int pullRequest();

    int16_t *getSamples();
    // int getFreq();
    // int setDivisor(int d);
    // void start();
    // void stop(MicroBit &ubit);

    int16_t *samples;
    int16_t dataPoint = 0;

    float *buf;
    uint16_t position;
    bool recording = false;

    int length = 0;

private:
};

#endif